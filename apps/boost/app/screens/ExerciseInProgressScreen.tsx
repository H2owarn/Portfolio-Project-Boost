// app/screens/ExerciseInProgressScreen.tsx
import React, { useState, useRef } from 'react';
import { View, Text, StyleSheet, Image, Dimensions, TextInput, Pressable, ScrollView, FlatList } from 'react-native';
import { useLocalSearchParams, Stack, router } from 'expo-router';
import { MaterialIcons } from '@expo/vector-icons';
import { supabase } from '@/lib/supabase';
import { Screen } from '@/components/layout/screen';
import { Colors, Radii, Spacing } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

const { width } = Dimensions.get('window');

type Exercise = {
  id: number;
  name: string;
  instructions: string[];
  images: string[];
  xp_reward: number;
  stamina_cost: number;
  category?: string;
  level?: string;
};

export default function ExerciseInProgressScreen() {
  const params = useLocalSearchParams();
  const palette = Colors[useColorScheme() ?? 'dark'];

  // Parse exercise data
  const exercise: Exercise = JSON.parse(params.exercise as string);

  const [currentImageIndex, setCurrentImageIndex] = useState(0);
  const [sets, setSets] = useState('0');
  const [reps, setReps] = useState('0');
  const [completing, setCompleting] = useState(false);
  const [imageLoading, setImageLoading] = useState<{ [key: number]: boolean }>({});
  const [imagesPrefetched, setImagesPrefetched] = useState(false);

  const flatListRef = useRef<FlatList>(null);

  // Prefetch all images when component mounts
  React.useEffect(() => {
    const prefetchImages = async () => {
      if (exercise.images && exercise.images.length > 0) {
        try {
          await Promise.all(
            exercise.images.map(imageUrl => Image.prefetch(imageUrl))
          );
          setImagesPrefetched(true);
        } catch (error) {
          console.error('Error prefetching images:', error);
          setImagesPrefetched(true); // Still set to true to show images
        }
      }
    };

    prefetchImages();
  }, [exercise.images]);

  const handleCompleteExercise = async () => {
    setCompleting(true);

    try {
      // Get current user
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        console.error('No user logged in');
        alert('Please log in to save your progress.');
        setCompleting(false);
        return;
      }

      // Validate input
      const numSets = parseInt(sets) || 0;
      const numReps = parseInt(reps) || 0;

      if (numSets <= 0 || numReps <= 0) {
        alert('Please enter valid numbers for sets and reps.');
        setCompleting(false);
        return;
      }

      // Fetch user profile
      const { data: profile, error: profErr } = await supabase
        .from("profiles")
        .select("stamina, exp")
        .eq("id", user.id)
        .single();

      if (profErr || !profile) {
        console.error("Profile fetch error:", profErr);
        alert("Could not fetch your profile.");
        setCompleting(false);
        return;
      }

      // Check stamina
      if (profile?.stamina < exercise.stamina_cost) {
        alert("Not enough stamina to complete this exercise!");
        setCompleting(false);
        return;
    }

    // compute new values

      const newStamina = profile.stamina - exercise.stamina_cost;
      const newExp = profile.exp + exercise.xp_reward;

      // Update profile stamina + exp
      const { error: updateErr } = await supabase
        .from("profiles")
        .update({ stamina: newStamina, exp: newExp })
        .eq("id", user.id);

        if (updateErr) {
        console.error("Profile update error:", updateErr);
        alert("Failed to update EXP or stamina.");
        setCompleting(false);
        return;
      }

      // Insert completed exercise with sets and reps
      const { error: insertErr } = await supabase
        .from('completed_exercises')
        .insert({
          user_id: user.id,
          exercise_id: exercise.id,
          sets: numSets,
          reps: numReps
          // created_at will be auto-generated by database
        });

          if (insertErr) {
          console.error("Error saving completed exercise:", insertErr);
          alert("Failed to save exercise. Please try again.");
          setCompleting(false);
          return;
        }

      if (insertErr) {
        console.error('Error saving completed exercise:', insertErr);
        alert('Failed to save exercise. Please try again.');
      } else {
        // Success! Navigate back or show success message
        alert(`Great job! You completed ${sets} sets of ${reps} reps and earned ${exercise.xp_reward} XP!`);
        router.back();
      }
    } catch (err) {
      console.error('Error completing exercise:', err);
      alert('An error occurred. Please try again.');
    } finally {
      setCompleting(false);
    }
  };

  const renderImage = ({ item, index }: { item: string; index: number }) => {
    const isLoading = !imagesPrefetched && imageLoading[index] !== false;

    return (
      <View style={styles.imageContainer}>
        {isLoading && (
          <View style={styles.loadingOverlay}>
            <MaterialIcons name="image" size={48} color={palette.mutedText} />
            <Text style={[styles.loadingText, { color: palette.mutedText }]}>Loading...</Text>
          </View>
        )}
        <Image
          source={{ uri: item }}
          style={styles.exerciseImage}
          resizeMode="contain"
          onLoadStart={() => setImageLoading(prev => ({ ...prev, [index]: true }))}
          onLoad={() => setImageLoading(prev => ({ ...prev, [index]: false }))}
          onError={() => setImageLoading(prev => ({ ...prev, [index]: false }))}
        />
      </View>
    );
  };

  const handleScroll = (event: any) => {
    const offsetX = event.nativeEvent.contentOffset.x;
    const index = Math.round(offsetX / width);
    setCurrentImageIndex(index);
  };

  return (
    <>
      <Stack.Screen options={{ title: exercise.name, }} />
      <Screen scrollable={false} contentStyle={styles.container}>
        {/* Images Carousel */}
        {exercise.images && exercise.images.length > 0 ? (
          <View style={styles.carouselSection}>
            <FlatList
              ref={flatListRef}
              data={exercise.images}
              renderItem={renderImage}
              keyExtractor={(item, index) => index.toString()}
              horizontal
              pagingEnabled
              showsHorizontalScrollIndicator={false}
              onScroll={handleScroll}
              scrollEventThrottle={16}
            />

            {/* Pagination Dots */}
            {exercise.images.length > 1 && (
              <View style={styles.paginationDots}>
                {exercise.images.map((_, index) => (
                <View
                  key={`dot-${index}`}
                  style={[
                    styles.dot,
                    index === currentImageIndex
                      ? { backgroundColor: palette.primary }
                      : { backgroundColor: palette.mutedText + '50' }
                  ]}
                />
              ))}
            </View>
          )}
          </View>
        ) : (
          <View style={[styles.carouselSection, styles.noImageContainer]}>
            <MaterialIcons name="image-not-supported" size={64} color={palette.mutedText} />
            <Text style={[styles.noImageText, { color: palette.mutedText }]}>No images available</Text>
          </View>
        )}

        {/* Exercise Info & Input Section */}
        <ScrollView style={styles.contentSection} contentContainerStyle={styles.contentPadding}>
          {/* Exercise Details */}
          <View style={styles.detailsCard}>
            <View style={styles.badges}>
              {exercise.level && (
                <View style={[styles.badge, { backgroundColor: palette.primary + '20' }]}>
                  <MaterialIcons name="signal-cellular-alt" size={14} color={palette.primary} />
                  <Text style={[styles.badgeText, { color: palette.primary }]}>{exercise.level}</Text>
                </View>
              )}
              {exercise.category && (
                <View style={[styles.badge, { backgroundColor: palette.primary + '20' }]}>
                  <MaterialIcons name="category" size={14} color={palette.primary} />
                  <Text style={[styles.badgeText, { color: palette.primary }]}>{exercise.category}</Text>
                </View>
              )}
            </View>

            <View style={styles.rewardInfo}>
              <View style={styles.rewardItem}>
                <MaterialIcons name="star" size={20} color={palette.primary} />
                <Text style={[styles.rewardText, { color: palette.text }]}>
                  +{exercise.xp_reward} XP
                </Text>
              </View>
              <View style={styles.rewardItem}>
                <MaterialIcons name="flash-on" size={20} color={palette.primary} />
                <Text style={[styles.rewardText, { color: palette.text }]}>
                  -{exercise.stamina_cost} Stamina
                </Text>
              </View>
            </View>
          </View>

          {/* Sets & Reps Input */}
          <View style={[styles.inputCard, { backgroundColor: palette.surface }]}>
            <View style={styles.inputRow}>
              <View style={styles.inputGroup}>
                <Text style={[styles.inputLabel, { color: palette.mutedText }]}>Sets</Text>
                <TextInput
                  style={[
                    styles.input,
                    {
                      backgroundColor: palette.background,
                      color: palette.text,
                      borderColor: palette.borderColor
                    }
                  ]}
                  value={sets}
                  onChangeText={setSets}
                  keyboardType="number-pad"
                  placeholder="0"
                  placeholderTextColor={palette.mutedText}
                />
              </View>

              <View style={styles.inputGroup}>
                <Text style={[styles.inputLabel, { color: palette.mutedText }]}>Reps</Text>
                <TextInput
                  style={[
                    styles.input,
                    {
                      backgroundColor: palette.background,
                      color: palette.text,
                      borderColor: palette.borderColor
                    }
                  ]}
                  value={reps}
                  onChangeText={setReps}
                  keyboardType="number-pad"
                  placeholder="0"
                  placeholderTextColor={palette.mutedText}
                />
              </View>
            </View>
          </View>

          {/* Complete Button */}
          <Pressable
            style={[
              styles.completeButton,
              { backgroundColor: palette.primary },
              completing && styles.buttonDisabled
            ]}
            onPress={handleCompleteExercise}
            disabled={completing}
          >
            <MaterialIcons name="check-circle" size={24} color="#000" />
            <Text style={styles.completeButtonText}>
              {completing ? 'Saving...' : 'Complete Exercise'}
            </Text>
          </Pressable>

          {/* All Instructions */}
          {exercise.instructions && exercise.instructions.length > 0 && (
            <View style={[styles.instructionsCard, { backgroundColor: palette.surface }]}>
              <Text style={[styles.sectionTitle, { color: palette.text }]}>Instructions</Text>
              {exercise.instructions.map((instruction, index) => (
                <View key={`instruction-${index}`} style={styles.instructionItem}>
                  <View style={[styles.stepNumber, { backgroundColor: palette.primary + '20' }]}>
                    <Text style={[styles.stepNumberText, { color: palette.primary }]}>
                      {index + 1}
                    </Text>
                  </View>
                  <Text style={[styles.instructionFullText, { color: palette.mutedText }]}>
                    {instruction}
                  </Text>
                </View>
              ))}
            </View>
          )}
        </ScrollView>
      </Screen>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1
  },
  carouselSection: {
    width: width,
    height: width * 0.75, // Back to original size
    backgroundColor: '#000',
    position: 'relative',
    marginTop: -40 // Move the entire carousel up
  },
  imageContainer: {
    width: width,
    height: width * 0.75,
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center'
  },
  loadingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1,
    gap: Spacing.sm
  },
  loadingText: {
    fontSize: 14,
    fontWeight: '500'
  },
  exerciseImage: {
    width: '100%',
    height: '100%'
  },
  paginationDots: {
    position: 'absolute',
    top: Spacing.md,
    right: Spacing.md,
    flexDirection: 'row',
    gap: 6
  },
  dot: {
    width: 8,
    height: 8,
    borderRadius: 4
  },
  contentSection: {
    flex: 1
  },
  contentPadding: {
    padding: Spacing.lg,
    gap: Spacing.sm
  },
  detailsCard: {
    gap: Spacing.md
  },
  badges: {
    flexDirection: 'row',
    gap: Spacing.xs
  },
  badge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: Radii.sm,
    gap: 4
  },
  badgeText: {
    fontSize: 12,
    fontWeight: '600',
    textTransform: 'capitalize'
  },
  rewardInfo: {
    flexDirection: 'row',
    gap: Spacing.md
  },
  rewardItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6
  },
  rewardText: {
    fontSize: 16,
    fontWeight: '600'
  },
  instructionsCard: {
    padding: Spacing.md,
    borderRadius: Radii.lg,
    gap: Spacing.md
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    marginBottom: Spacing.xs
  },
  instructionItem: {
    flexDirection: 'row',
    gap: Spacing.sm,
    alignItems: 'flex-start'
  },
  stepNumber: {
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 2
  },
  stepNumberText: {
    fontSize: 14,
    fontWeight: '700'
  },
  instructionFullText: {
    flex: 1,
    fontSize: 14,
    lineHeight: 22
  },
  inputCard: {
    padding: Spacing.sm,
    borderRadius: Radii.lg,
    gap: Spacing.sm
  },
  inputRow: {
    flexDirection: 'row',
    gap: Spacing.md
  },
  inputGroup: {
    flex: 1,
    gap: Spacing.xs
  },
  inputLabel: {
    fontSize: 14,
    fontWeight: '600',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    textAlign: 'center'
  },
  input: {
    height: 56,
    borderRadius: Radii.md,
    borderWidth: 2,
    paddingHorizontal: Spacing.md,
    fontSize: 24,
    fontWeight: '700',
    textAlign: 'center'
  },
  completeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: Spacing.md,
    borderRadius: Radii.lg,
    gap: Spacing.sm,
    marginTop: Spacing.md
  },
  buttonDisabled: {
    opacity: 0.6
  },
  completeButtonText: {
    fontSize: 18,
    fontWeight: '700',
    color: '#000'
  },
  noImageContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    gap: Spacing.md,
    backgroundColor: '#000'
  },
  noImageText: {
    fontSize: 16,
    fontWeight: '500'
  }
});
